/* TSIRONIS ILIAS , AEM 2851 * PETEINARELIS CHARALAMPOS , AEM 2804 * This is an agenda-type database program; it uses memory dynamically so as to perform basic functions on a number of students' student_list data  * (aem,name,courses_left) such as adding,removing,modifying,finding,sorting,printing and deleting them. *  * NOTE: The hash_table, often referred to as the pointer array is an array containing pointers to all the student_lists of the students' agenda. */#include <stdio.h>#include <string.h>#include <stdlib.h>#include <time.h>struct courses_list {	short unsigned int subject_num;	struct courses_list *nxt;};struct student_list {/*The student_list struct definition*/	long unsigned int aem;	char name[64];	short unsigned int courses_left;    struct student_list *nxt;    struct student_list *prev;	struct courses_list *courses;};/*The function prototypes*/unsigned long hash(char *str);void upper_string(char str[]);struct student_list **add_stud(struct student_list **hash_table, int *hash_table_size, int *signs_num);struct student_list *find (struct student_list **hash_table, char name[], int pos);void print(struct student_list **hash_table,int *hash_table_size, int *signs_num);void clear (struct student_list **hash_table, int *hash_table_size);void mod(struct student_list **hash_table,int *hash_table_size);struct student_list **rmv(struct student_list **hash_table, int *hash_table_size, int *signs_num);void reg(struct student_list **hash_table, int *hash_table_size);void unreg (struct student_list **hash_table, int *hash_table_size);void isreg (struct student_list **hash_table, int *hash_table_size);void list(struct student_list **hash_table, int *hash_table_size);int main (int argc, char *argv[]) { /*The main function*/ 	int i; /*some variables helping out through main*/	struct student_list **hash_table;	struct student_list *find_ptr;	int *hash_table_size, *signs_num_ptr;	int hash_size, pos, number_of_signs;	char option, name[64];	clock_t start, end;		if(argc > 1) {/*checking if there is a command line argument given*/		hash_size = atoi(argv[1]);	}	else {		hash_size = 8;	}		hash_table = (struct student_list **)malloc((hash_size) * sizeof(struct student_list *));		if(hash_table == NULL){		return 0;	}	for( i = 0; i < hash_size; i ++) { /*initialization of the pointer array to NULL*/		hash_table[i] = NULL;	}		hash_table_size = &hash_size;	number_of_signs = 0;	signs_num_ptr = &number_of_signs;		while(1) {		scanf("%c", &option);				if (option == 'a') {			hash_table = add_stud(hash_table, hash_table_size, signs_num_ptr);		}		if (option == 'r') {			hash_table = rmv(hash_table, hash_table_size, signs_num_ptr);		}		if (option == 'm') {			mod(hash_table, hash_table_size);		}		if (option == 'f') {			scanf("%63s", name);			upper_string(name);						start = clock();			printf("\n");						pos = hash(name) % (*hash_table_size);						find_ptr = find(hash_table, name, pos);						if ( find_ptr != NULL) {				printf("#\nF-OK %ld %hd\n", find_ptr->aem, find_ptr->courses_left);			}			else {				printf("F-NOK %s\n", name);// 				comparisons = real_size;			}			end = clock();//             printf("\ntime: #%ld\n", end - start); 		}		if (option == 'p') { 			print(hash_table, hash_table_size, signs_num_ptr);		}		if (option == 'c') {						clear(hash_table, hash_table_size);			printf("C-OK\n");						if(argc > 1) {/*checking if there is a command line argument given*/				hash_size = atoi(argv[1]);			}			else {				hash_size = 8;			}						number_of_signs = 0;						hash_table = (struct student_list **)malloc((hash_size) * sizeof(struct student_list *));/*this is to create a new pointer array; that way we will be able to add student_lists after clearing*/			if(hash_table == NULL){				return 0;			}			for( i = 0; i < hash_size; i ++) { /*initialization of the pointer array to NULL*/				hash_table[i] = NULL;			}		}		if (option == 'g') {			reg(hash_table, hash_table_size);		}		if (option == 'u') {			unreg(hash_table, hash_table_size);		}		if (option == 'i') {			isreg(hash_table, hash_table_size);		}		if (option == 'l') {			list(hash_table, hash_table_size);		}		if (option == 'q') {			clear(hash_table, hash_table_size);			break;		}	}		return 0;}unsigned long hash(char *str) {       unsigned long hash = 5381;    int c;    	while ((c = *str++)) {        hash = ((hash << 5) + hash) + c;	}    return (hash);}void upper_string(char str[]) { /*Function that makes the letters of a name capital*/	int i = 0;		while (str[i] != '\0') {		if (str[i] >= 'a' && str[i] <= 'z') {			str[i] = str[i] - 32;  /*32 is the difference between 'A' and 'a' according to the ASCII table. Literals arithmetics are performed here*/		}			i++;	}}int num_of_buckets(int i, struct student_list **hash_table) {	int num = 0;	struct student_list *curr;		for(curr = hash_table[i]; curr != NULL; curr = curr->nxt) {		num = num + 1;	}		return num;}int max_search(int *hash_table_size ,int arr[]) {	int max, i;		max = arr[0];		for(i = 1; i < *hash_table_size; i++){		if (max < arr[i]) {			max = arr[i];		}	}	return(max);}struct student_list **add_stud(struct student_list **hash_table, int *hash_table_size, int *signs_num) {	struct student_list *new_student, *curr;	long unsigned int aem;	char name[64];	short unsigned int courses;	struct student_list *find_ptr, **new_hash_table, *new_curr, *temp;	int pos;	double load_factor;	int i;	int new_table_size;    	scanf("%ld %63s %hd", &aem, name, &courses);	upper_string(name);		printf("\n");		pos = hash(name) % (*hash_table_size);	find_ptr = find(hash_table, name, pos);		if (find_ptr != NULL) {		printf("A-NOK %s\n", name);		return(hash_table);	}	for ( i = 0; i < *hash_table_size; i++) {		if ( hash_table[i] != NULL) {			for(curr = hash_table[i]; curr != NULL; curr = curr->nxt) {				if (curr->aem == aem) {					printf("A-NOK %ld\n", aem);					return(hash_table);				}			}		}	}		new_student = (struct student_list *)malloc(sizeof(struct student_list));	new_student->aem = aem;	new_student->courses_left = courses;	strcpy(new_student->name, name);	new_student->nxt = NULL;	new_student->prev = NULL;	new_student->courses = (struct courses_list *)malloc(sizeof(struct courses_list));	new_student->courses->subject_num = 0;	new_student->courses->nxt = NULL;		*signs_num = *signs_num + 1;		load_factor = (double)(*signs_num)/(*hash_table_size);		if (hash_table[pos] != NULL) {		for(curr = hash_table[pos]; (curr->nxt != NULL) && (strcmp(name, curr->name) > 0); curr = curr->nxt);				if (curr->nxt == NULL) {			if (strcmp(name, curr->name) > 0) {				curr->nxt = new_student;				new_student->prev = curr;				new_student->nxt = NULL;			}			else {				if (curr->prev != NULL) {					curr->prev->nxt = new_student;					new_student->nxt = curr;					new_student->prev = curr->prev;					curr->prev = new_student;				}				else {					hash_table[pos] = new_student;					curr->prev = new_student;					new_student->nxt = curr;				}			}		}		else {			if (curr->prev != NULL) {				curr->prev->nxt = new_student;				new_student->nxt = curr;				new_student->prev = curr->prev;				curr->prev = new_student;			}			else {				hash_table[pos] = new_student;				new_student->prev = NULL;				new_student->nxt = curr;				curr->prev = new_student;			}		}	}	else {		hash_table[pos] = new_student;		new_student->prev = NULL;	}			if (load_factor >= 4.0) {		new_table_size = *hash_table_size * 2;		new_hash_table = (struct student_list **)malloc(new_table_size * sizeof(struct student_list *));				for(i = 0; i < new_table_size; i++) {			new_hash_table[i] = NULL;		}				for(i = 0; i < *hash_table_size; i++) {			if(hash_table[i] != NULL) {				for(curr = hash_table[i]; curr != NULL; curr = temp) {					pos = hash(curr->name) % new_table_size;										temp = curr->nxt;                        					if(new_hash_table[pos] == NULL) {						new_hash_table[pos] = curr;						curr->nxt = NULL;						curr->prev = NULL;					}					else{						for(new_curr = new_hash_table[pos]; new_curr->nxt != NULL && strcmp(curr->name, new_curr->name) > 0; new_curr = new_curr->nxt);												if(new_curr->nxt == NULL) {							new_curr->nxt = curr;							curr->nxt = NULL;							curr->prev = new_curr;						}    						else {							if(new_curr->prev != NULL) {								new_curr->prev->nxt = curr;								curr->prev =  new_curr->prev;								curr->nxt = new_curr;								new_curr->prev = curr;							}							else {								new_hash_table[pos] = curr;								curr->prev = NULL;								curr->nxt = new_curr;								new_curr->prev = curr;							}						}											}				}			}		}		free(hash_table);		*hash_table_size = new_table_size;// 		print(new_hash_table, hash_table_size, signs_num);		return (new_hash_table);	}		printf("A-OK\n");	return(hash_table);}struct student_list *find (struct student_list **hash_table, char name[], int pos) {     struct student_list *curr;	int i;			if (hash_table[pos] ==  NULL) {// 		printf("\nCOMPARISONS: 0\n");				return(NULL);	}		for(curr = hash_table[pos], i = 0; strcmp(name, curr->name) > 0 && curr->nxt != NULL; curr = curr->nxt, i= i + 1);		if (curr->nxt != NULL) {		if (strcmp(name, curr->name) == 0) {// 			printf("\nCOMPARISONS: %d\n", i);			return (curr);		}		else {// 			printf("\nCOMPARISONS: %d\n", i);			return (NULL);		}	}	else {		if (strcmp(name, curr->name) == 0) {// 			printf("\nCOMPARISONS: %d\n", i);			return (curr);		}		else {// 			printf("\nCOMPARISONS: %d\n", i);			return (NULL);		}	}	return(curr);}void print(struct student_list **hash_table,int *hash_table_size, int *signs_num) {  /*Function that prints all the student_lists along with their individual data(aem, name, courses_left left)    Parameters: the pointer array, the array's number of student_lists*/	int i, array[*hash_table_size];	struct student_list *stud_ptr;	double load_factor;	int largest_buck;		for(i = 0; i < *hash_table_size; i++) {		array[i] = 0;		array[i] = num_of_buckets(i, hash_table);	}		largest_buck = max_search(hash_table_size, array); 	load_factor = (double)(*signs_num)/ (*hash_table_size);		printf("\n#\n");	printf("%d %d %.2lf %d\n",*hash_table_size, *signs_num, load_factor, largest_buck);	for(i = 0; i < *hash_table_size; i++) {		if(hash_table[i] != NULL) {			printf("%d %d", i, array[i]);						for(stud_ptr = hash_table[i]; stud_ptr != NULL; stud_ptr = stud_ptr->nxt) {				printf(" [%ld %s %hd]", stud_ptr->aem, stud_ptr->name, stud_ptr->courses_left);			}			printf("\n\n");		}		else { 			printf("%d %d\n\n", i, array[i]);		}	}}void clear (struct student_list **hash_table, int *hash_table_size) { /*Function that completely deletes all the student_lists from the pointer array    Parameters: the pointer array, a pointer to the array's number of student_lists*/	int i;	struct student_list *stud_ptr;	struct courses_list *course_ptr;		for(i = 0; i < *hash_table_size; i++) {		for(stud_ptr = hash_table[i]; stud_ptr != NULL; stud_ptr = stud_ptr->nxt) {			for(course_ptr = stud_ptr->courses; course_ptr->nxt != NULL; course_ptr = course_ptr->nxt) {				free(course_ptr);			} 			if(stud_ptr != NULL) { 				free(stud_ptr);			}		}	}		free(hash_table);		*hash_table_size = 0;}void mod(struct student_list **hash_table, int *hash_table_size) {  /*Function that modifies a particular student_list's courses_left field.    Parameters: the pointer array, the array's number of student_lists*/	int courses_left;	int pos;	char name[64];	struct student_list *find_ptr;		scanf("%s %d", name, &courses_left);	upper_string(name);		printf("\n");		pos = hash(name) % (*hash_table_size);		find_ptr = find(hash_table, name, pos);  /*searching by name with find */		if (find_ptr != NULL) { /*checking if the name is found*/		find_ptr->courses_left = courses_left;		printf("M-OK\n");	}	else {		printf("M-NOK %s\n", name);	}	}struct student_list **rmv(struct student_list **hash_table, int *hash_table_size, int *signs_num) {  /*Function that removes a student_list form the pointer array.    Parameters: the pointer array, a pointer to the array's number of student_lists    Returns: a pointer to the changed pointer array*/    struct student_list *find_ptr, *temp, *curr, *new_curr, **new_hash_table;	struct courses_list *course_ptr;	int pos;	char name[64];	double load_factor;	int i;	int new_table_size;    	scanf("%s", name);	upper_string(name);		pos = hash(name) % (*hash_table_size);		find_ptr = find(hash_table, name, pos);    printf("\n");		if (find_ptr == NULL) {		printf("R-NOK %s\n", name);		return (hash_table);	}	else {		if (find_ptr->nxt == NULL) {			if (find_ptr->prev == NULL) {				for(course_ptr = find_ptr->courses; course_ptr != NULL; course_ptr = course_ptr->nxt) {					free(course_ptr);				}					free(find_ptr);				hash_table[pos] = NULL;			}			else {				find_ptr->prev->nxt = NULL;				for(course_ptr = find_ptr->courses; course_ptr != NULL; course_ptr = course_ptr->nxt) {					free(course_ptr);				}				free(find_ptr);			}		}		else {			if (find_ptr->prev == NULL) { 				hash_table[pos] = find_ptr->nxt;				find_ptr->nxt->prev = NULL;				for(course_ptr = find_ptr->courses; course_ptr != NULL; course_ptr = course_ptr->nxt) {					free(course_ptr);				}				free(find_ptr);			}			else {				find_ptr->prev->nxt = find_ptr->nxt;				find_ptr->nxt->prev = find_ptr->prev;				for(course_ptr = find_ptr->courses; course_ptr != NULL; course_ptr = course_ptr->nxt) {					free(course_ptr);				}				free(find_ptr);			}		}		*signs_num = *signs_num - 1;		load_factor = (double)(*signs_num)/(*hash_table_size);					if (load_factor == 1.0) {		new_table_size = *hash_table_size / 2;		new_hash_table = (struct student_list **)malloc(new_table_size * sizeof(struct student_list *));				for(i = 0; i < new_table_size; i++) {			new_hash_table[i] = NULL;		}				for(i = 0; i < *hash_table_size; i++) {			if(hash_table[i] != NULL) {  				for(curr = hash_table[i]; curr != NULL; curr = temp) {					pos = hash(curr->name) % new_table_size;										temp = curr->nxt;										if(new_hash_table[pos] == NULL) {						new_hash_table[pos] = curr;						curr->nxt = NULL;						curr->prev = NULL;					}					else{						for(new_curr = new_hash_table[pos]; new_curr->nxt != NULL && strcmp(curr->name, new_curr->name) > 0; new_curr = new_curr->nxt);												if(new_curr->nxt == NULL) {							new_curr->nxt = curr;							curr->nxt = NULL;							curr->prev = new_curr;						}    						else {							if(new_curr->prev != NULL) {								new_curr->prev->nxt = curr;								curr->prev =  new_curr->prev;								curr->nxt = new_curr;								new_curr->prev = curr;							}							else {								new_hash_table[pos] = curr;								curr->prev = NULL;								curr->nxt = new_curr;								new_curr->prev = curr;							}						}					}				}			}		}		free(hash_table);		printf("R-OK\n");		*hash_table_size = new_table_size;		return (new_hash_table);	}		printf("R-OK\n");	return(hash_table);	}}void reg(struct student_list **hash_table,int *hash_table_size) { 	char name[64]; 	unsigned short int course_num;	int pos;	struct courses_list *prev, *curr, *temp;	struct student_list *find_ptr;		scanf("%63s %hd", name, &course_num);	upper_string(name);		printf("\n");		pos = hash(name) % (*hash_table_size);		find_ptr = find(hash_table, name, pos);		if (find_ptr == NULL) {		printf("G-NOK %s\n", name);		return;	}		for(prev = NULL, curr = find_ptr->courses; (curr->nxt != NULL) && (course_num > curr->subject_num ); prev = curr, curr = curr->nxt);	    if ( course_num == curr->subject_num ) {		printf("G-NOK %hd\n", course_num);		return;	}		if (curr->nxt != NULL) {		temp = (struct courses_list *)malloc(sizeof(struct courses_list));						temp->subject_num = course_num;			temp->nxt = curr;						prev->nxt = temp;	}	else {		if (curr->subject_num > course_num ) {			temp = (struct courses_list *)malloc(sizeof(struct courses_list));						temp->subject_num = course_num;            temp->nxt = curr;            prev->nxt = temp;					}		else if ( curr->subject_num < course_num ) {			temp = (struct courses_list *)malloc(sizeof(struct courses_list));						temp->subject_num = course_num;            temp->nxt = NULL;            curr->nxt = temp;			        }	}	printf("G-OK\n");}void unreg (struct student_list **hash_table, int *hash_table_size) {	char name[64];	unsigned short int course_num;	int pos;	struct courses_list *prev, *curr;	struct student_list *find_ptr;	    scanf("%63s %hd", name, &course_num);	upper_string(name);		printf("\n");		pos = hash(name) % (*hash_table_size);		find_ptr = find(hash_table, name, pos);		if(find_ptr == NULL) {		printf("U-NOK %s\n", name);		return;	}	    for(prev = NULL, curr = find_ptr->courses; (curr->nxt != NULL) && (course_num != curr->subject_num ); prev = curr, curr = curr->nxt);	if (course_num == curr->subject_num) {		prev->nxt = curr->nxt;		free(curr);		printf("U-OK\n");	}	else {		printf("U-NOK %hd\n", course_num);	}}void isreg (struct student_list **hash_table, int *hash_table_size) {	char name[64];	short unsigned int subject_num;	int pos;	struct courses_list *curr;	struct student_list *find_ptr;		scanf("%63s %hd", name, &subject_num);	upper_string(name);		printf("\n");		pos = hash(name) % (*hash_table_size);		find_ptr = find(hash_table, name, pos);		if (find_ptr == NULL) {		printf("I-NOK %s\n", name);		return;	}		for(curr = find_ptr->courses; curr != NULL && curr->subject_num != subject_num; curr = curr->nxt);		if (curr == NULL) {		printf("NO\n");	}	else {		if (curr->subject_num == subject_num) {			printf("YES\n");		}		else {			printf("NO\n");		}	}}void list(struct student_list **hash_table, int *hash_table_size) {	char name[64];	int pos;	struct student_list *find_ptr;	struct courses_list *curr;		scanf(" %63s", name);	upper_string(name);				pos = hash(name) % (*hash_table_size);		find_ptr = find(hash_table, name, pos);		if (find_ptr == NULL) {		printf("\nL-NOK %s\n", name);		return;	}	printf("\n#\n");	printf("%s\n", find_ptr->name);	for(curr = find_ptr->courses->nxt; curr != NULL; curr = curr->nxt) {		printf("%hd\n", curr->subject_num);	}}